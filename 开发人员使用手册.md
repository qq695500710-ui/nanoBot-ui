# 开发人员使用手册（newui.exe + 外置 nanobot-main）

本手册面向**开发者/运维/高级用户**，用于说明打包后的 `newui.exe` 如何加载同级 `nanobot-main/`、配置路径、依赖安装机制、技能（Skills）与 MCP Server 的开发规范与接入方法。

---

### 1. 发行包的推荐结构（关键：nanobot-main 可替换更新）

standalone 模式下，真正要分发的是 `newui.dist/` 目录（里面包含 `newui.exe` 和运行时依赖）。

推荐结构：

```
newui.dist/
  newui.exe
  nanobot-main/               # 外置：从 https://github.com/HKUDS/nanobot 下载并解压/克隆
    nanobot/
    pyproject.toml
    requirements.txt
    ...
  (Nuitka 生成的其它运行时依赖)
```

升级 nanobot（无需重打 newui）：

- 用新版项目**整体替换** `newui.exe` 同级目录的 `nanobot-main/`。

---

### 2. 运行时路径与持久化数据

newui / nanobot 的核心持久化位置（Windows）：

- **nanobot 主配置**：`%USERPROFILE%\.nanobot\config.json`
- **newui 状态目录**：`%USERPROFILE%\.nanobot\newui\`
  - **newui 日志**：`%USERPROFILE%\.nanobot\newui\newui.log`
  - **newui 会话持久化**：`%USERPROFILE%\.nanobot\newui\sessions.json`
  - **打包版可写依赖目录（vendor site-packages）**：
    - `%USERPROFILE%\.nanobot\newui\vendor\site-packages\`
- **workspace**（技能/工作文件等）：`%USERPROFILE%\.nanobot\workspace\`
  - skills：`%USERPROFILE%\.nanobot\workspace\skills\`

---

### 3. newui.exe 如何加载 nanobot-main（外置热更新的实现要点）

`newui.exe` 启动时会按以下策略定位并加载 nanobot：

- 优先检查 `newui.exe` 同级目录是否存在 `nanobot-main\nanobot\cli\commands.py`
- 若存在：把 `nanobot-main/` 加到 `sys.path` 前部（优先用外置源码）
- 若不存在：UI 仍可启动，但 embedded agent/gateway 相关功能会在日志中给出导入失败信息

结论：

- **只要你把 `nanobot-main/` 放在 `newui.exe` 同级目录**，就可以随项目更新替换源码，newui 不用重新打包。

#### 3.1 LLM 接口配置（面向交付/运维的检查清单）

在 newui 里通过 **设置 → 设置 API Key** 完成配置。该对话框会写入：

- `providers.<provider>.apiKey`（及可选的 `apiBase`）
- `agents.defaults.model`

建议运维交付时至少验证一次：

- 点击 **测试连接**（会发一个极小请求 “Say OK”）
- 确认返回 ok，再保存

常见踩坑（newui 里也会提示）：

- 不要把某家的 key 配到另一家的 API Base（典型：DeepSeek key + openrouter.ai base）
- 自定义兼容接口（Custom）通常需要 `apiBase` 以 `/v1` 结尾

---

### 4. “设置 → 安装依赖”的工作机制（开发者必须理解）

开发人员拿到的是**打包后的 `newui.exe`**，交付目标是“目标机器无需安装 Python 环境”。

因此这里仅讨论**打包态（newui.exe）**的依赖安装机制：

- 不依赖系统 Python
- 使用 newui 打包环境内置的 pip（`pip._internal`）执行安装
- 通过 `--target` 把依赖安装到（用户可写、可持久化、可覆盖打包内置库）：

`%USERPROFILE%\.nanobot\newui\vendor\site-packages\`

并且 newui 启动时会把该目录插入到 `sys.path` 前部，保证：

- 新装的依赖优先级高于打包内置依赖
- nanobot-main 更新带来的新依赖缺失，可以通过 UI 补装

推荐流程（运维/交付）：

- newui.exe 首次交付时尽量把 `nanobot-main/requirements.txt` 中常用依赖都打包进 dist
- 遇到升级缺依赖时，让用户在 UI 里安装缺失模块名，然后重启

---

### 5. 缺依赖/缺数据文件的诊断与修复

embedded agent 启动失败时，你会在日志看到：

- `[agent] 启动失败：...`

常见两类：

#### 5.1 `ModuleNotFoundError: No module named 'xxx'`

- UI 引导：到 **设置 → 安装依赖** 安装 `xxx`（或 `pip install xxx`）
- 安装后重启 newui.exe

#### 5.2 第三方包“数据文件缺失”（例如 LiteLLM 的 `endpoints.json`）

这类问题通常是打包时没包含包内数据文件导致。

两条路：

- **运行时兜底**：在 UI 里 `pip install -U <package>`（装到 vendor 目录覆盖）
- **重新打包修复**：使用 Nuitka 的 `--include-package-data=<package>`

参考：Nuitka standalone 对数据文件的说明见 [Nuitka Use Cases — Standalone Program Distribution](https://nuitka.net/user-documentation/use-cases.html)。

---

### 6. Skills（技能）开发规范与接入

#### 6.1 目录结构与优先级

skills 的生效位置（workspace）：

- `%USERPROFILE%\.nanobot\workspace\skills\<skill-name>\SKILL.md`

优先级：

- workspace skills **高于** nanobot 内置 builtin skills

#### 6.2 SKILL.md 的最小规范（nanobot SkillsLoader）

每个技能是一个文件夹，至少包含一个 `SKILL.md`，并建议带 YAML frontmatter：

```markdown
---
name: my-skill
description: 用于演示的技能：教 agent 如何调用某个本地程序完成固定流程
metadata: '{"nanobot": {"requires": {"bins": ["git"], "env": []}, "always": false}}'
---

## 触发条件
- 当用户说“按技能 my-skill ...”时使用

## 工作流程
1) ...
2) ...
```

requirements 规则（用于“技能管理”里显示可用/不可用）：

- `metadata` 里 JSON 的 `nanobot.requires.bins`：检查 `shutil.which()` 是否存在（例如 `git`、`node`）
- `metadata` 里 JSON 的 `nanobot.requires.env`：检查环境变量是否存在

#### 6.2.1 推荐的 frontmatter 写法（更兼容、更好用）

`SkillsLoader` 只做了非常轻量的 frontmatter 解析（按行拆 `key: value`），因此建议：

- `name`、`description` 用最简单的字符串
- `metadata` 用**单行 JSON 字符串**（避免多行 YAML 解析差异）

示例：

```markdown
---
name: my-skill
description: 在 Windows 上自动化调用本机程序（示例技能）
metadata: '{"nanobot": {"requires": {"bins": [], "env": []}, "always": false}}'
---
```

#### 6.2.2 “只靠 newui.exe”开发技能的实操流程

因为目标机不要求安装 Python，你可以把技能当作“可复制的文件夹模板”来交付：

1) 在 newui 打开 **技能管理 → 打开 skills 目录**  
2) 新建文件夹：`%USERPROFILE%\.nanobot\workspace\skills\my-skill\`  
3) 在该文件夹里创建 `SKILL.md`（用记事本即可）  
4) 回到 newui → 技能管理 → 刷新列表 → 预览确认内容正确  
5) 在聊天里测试：**“按技能 my-skill 做……”**

#### 6.2.3 示例：一个“调用本机 exe”的技能（可直接复制改名）

下面示例会指导 agent 使用 `exec` 来运行本机程序。你需要把路径按目标机实际情况改掉：

```markdown
---
name: run-local-exe
description: 运行本机的 exe/批处理，并把输出回传到聊天与日志。
metadata: '{"nanobot": {"requires": {"bins": [], "env": []}, "always": false}}'
---

## 适用场景
- 用户说“运行某个本机程序/脚本/批处理”
- 需要把执行过程输出到日志，避免用户以为卡住

## 工作流程（Windows）
1) 先向用户确认要运行的可执行文件路径与参数（如果路径不明确）。
2) 调用 exec 工具执行（PowerShell 或 cmd 均可）。
3) 读取 exec 输出并总结执行结果（成功/失败、退出码、关键输出）。

## 推荐的 exec 模板（示例）
- 运行一个 exe：
  - command: `cmd /c \"C:\\\\Tools\\\\MyApp\\\\myapp.exe\" --help`
- 运行一个 bat：
  - command: `cmd /c \"C:\\\\Tools\\\\do_something.bat\"`

## 注意事项
- 不要凭空假设路径存在；必要时先 exec 列目录确认。
- 避免 destructive 操作（删除/覆盖）除非用户明确要求。
```

你也可以把需要的“参考文档/参数说明/模板文件”放到同目录的 `references/`、`assets/`，并在 SKILL.md 里提示何时读取。

#### 6.3 资源组织（建议）

内置 skill-creator 的建议结构（可选）：

```
my-skill/
  SKILL.md
  scripts/        # 可执行脚本（Python/Bash/etc）
  references/     # 需要时再 read_file 的参考文档
  assets/         # 产物模板/图标/素材等（通常不进上下文）
```

原则：SKILL.md 保持简洁，把大段参考内容放到 `references/`（减少上下文浪费）。

#### 6.4 在 newui 里接入/验证技能

- 打开 **“技能管理”**
  - 新建自定义技能（生成模板）
  - 或导入技能文件夹（必须包含 `SKILL.md`）
  - 或启用内置技能（复制到 workspace）
- 回到会话窗口测试：
  - “按技能 <skill-name> 做……”

#### 6.5 调用技能的“稳定口令”（便于测试/交付）

为了让模型更稳定地触发技能，建议在用户侧这样说：

- “请**按技能** `<skill-name>` 执行：……”
- “先读 `<skill-name>` 的 SKILL.md，再按里面步骤做：……”

如果你希望模型必须执行而不是“口头指导”，可以补一句：

- “需要真实执行，请调用工具（exec 等），并把工具输出贴出来。”

---

### 7. MCP Servers（外部工具）开发与接入

newui 的 MCP 管理界面会把配置写入 `config.json` 的：

- `tools.mcpServers`（兼容 `tools.mcp_servers`）

工具命名：

- `mcp_<serverName>_<toolName>`

#### 7.1 配置方式（newui 里的字段含义）

1) **stdio 模式**（本机启动，nanobot 自动拉起进程并通过 stdio 通信）

在 newui 的 MCP editor 里填写：

- **`command`**：可执行命令（典型是 `xxx.exe`、`npx`、`node` 等）
- **`args`**：参数（空格分隔）
- **`env`**：仅 stdio 用（JSON，会作为子进程环境变量注入）

2) **HTTP 模式**

- **`url`**：MCP 的 HTTP endpoint（你需要在外部先把 server 跑起来；或者使用远程服务）

#### 7.2 交付场景的关键限制（非常重要）

你的交付目标是“目标机只有 `newui.exe`，不要求安装 Python 环境”。因此：

- **stdio MCP server 必须是目标机能直接运行的命令**（最常见是独立 exe）。
- 如果 MCP server 是 Python 写的：
  - 不要依赖 `python -m your_server`（目标机可能没有 python）
  - 推荐把 server **单独打包成 exe**，或改成 **HTTP 模式**把 server 放到服务器端

#### 7.3 推荐的 MCP 开发路线（按“不挑电脑”优先级排序）

##### 路线 A：HTTP MCP（最推荐）

适合：你希望目标机真正做到“只要 newui.exe + 网络就能用”。

步骤：

1) 你在服务器/容器部署 MCP（HTTP/SSE）服务，拿到 `url`
2) newui → **MCP Servers 管理** → 新增（HTTP）：填 `url`
3) 点“测试连接/列出工具（全部）”，确认出现 `mcp_<server>_<tool>`

##### 路线 B：stdio MCP（独立 exe）

适合：你希望离线/局域网可用，且不依赖系统 Python。

步骤：

1) 编写 MCP server（语言不限；Python 也可以，但最终要打成 exe）
2) 打包生成 `my_mcp_server.exe`
3) 把 exe 放到目标机（建议与 `newui.exe` 同级，或固定 `tools\` 目录）
4) newui → **MCP Servers 管理** → 新增（stdio）：
   - `command`: `C:\path\to\my_mcp_server.exe`
   - `args`: 按你的 server 约定填写（例如 `--mode stdio`）
5) 测试连接/列出工具

##### 路线 C：stdio MCP（Node / npx）

适合：复用社区现成 MCP server（但目标机需要安装 Node.js）。

示例（filesystem MCP）：

- `command`: `npx`
- `args`: `-y @modelcontextprotocol/server-filesystem D:\data`

#### 7.4 Python MCP server 示例（开发者示意）

nanobot 依赖 `mcp`，你可以用 `mcp.server.fastmcp` 快速写一个 server（示例伪代码）：

```python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("demo")

@mcp.tool()
def hello(name: str) -> str:
    return f"hello {name}"

if __name__ == "__main__":
    # 具体启动方式以nanobot官方文档为准（stdio 或 http/sse）
    mcp.run()
```

注意：如果你希望“目标机不装 Python”，请把该 server 打包成独立 exe（对应 7.3 路线 B），或改成 HTTP 路线。

#### 7.5 在聊天里调用 MCP 工具（标准测试口令）

- 自然语言：  
  “帮我用 `<serverName>` 的 `<toolName>` 做 xxx”
- 指定工具名（更稳定，便于回归测试）：  
  “使用工具 `mcp_<serverName>_<toolName>`，参数为 `{...}`”

#### 7.6 在 newui 里验证 MCP

在 **“MCP Servers 管理”**：

- 点 **“测试连接/列出工具（全部）”**
- 确认出现 `mcp_demo_hello` 之类的工具名

---

### 8. 任务与可观测性（Spawn / Cron / 日志）

- **Cron 定时任务**：newui 操作的是 nanobot 的 `jobs.json` 存储；网关运行时不会热加载，新增/删除任务后建议按提示重启网关。
- **后台任务面板（spawn）**：当模型调用 `spawn` 启动子代理任务时，会显示运行中的任务 ID。
- **操作状态栏 + 详情窗口**：用于可视化展示“正在做什么/耗时/工具调用输出”，降低“看起来卡死”的误解。

---

### 9. 安全与交付建议

- 如果要面向不懂电脑的用户分发，建议默认把 `tools.restrictToWorkspace` 配置为 `true`（更安全），但这会限制执行/读写范围。
- 如果你的目标是自动化调用本机其它程序（exe/bat 等），需要放宽限制；同时要加强提示与权限控制。
- 强烈建议把 newui 的“安装依赖”作为兜底方案，而不是默认安装路径：交付包尽量带全依赖，用户只在升级时补装。

